import inspect
from typing import Literal, Callable, Any
from warnings import warn

import numpy as np
from numpy.typing import ArrayLike

from ...utils import subsample_array, ArrayProtocol

# must take arguments: array-like, `axis`: int, `keepdims`: bool
WindowFuncCallable = Callable[[ArrayLike, int, bool], ArrayLike]


class NDProcessor:
    def __init__(
        self,
        data,
        n_display_dims: Literal[2, 3] = 2,
        slider_index_maps: tuple[Callable[[Any], int] | None, ...] | None = None,
        window_funcs: tuple[WindowFuncCallable | None] | None = None,
        window_sizes: tuple[int | None] | None = None,
        window_order: tuple[int, ...] = None,
        spatial_func: Callable[[ArrayProtocol], ArrayProtocol] | None = None,
    ):
        self._data = self._validate_data(data)
        self._slider_index_maps = self._validate_slider_index_maps(slider_index_maps)

        self.window_funcs = window_funcs
        self.window_sizes = window_sizes
        self.window_order = window_order

    @property
    def data(self) -> ArrayProtocol:
        return self._data

    @data.setter
    def data(self, data: ArrayProtocol):
        self._data = self._validate_data(data)

    @property
    def shape(self) -> tuple[int, ...]:
        return self.data.shape

    @property
    def ndim(self) -> int:
        return int(np.prod(self.shape))

    def _validate_data(self, data: ArrayProtocol):
        if not isinstance(data, ArrayProtocol):
            raise TypeError("`data` must implement the ArrayProtocol")

        return data

    @property
    def window_funcs(
        self,
    ) -> tuple[WindowFuncCallable | None, ...] | None:
        """get or set window functions, see docstring for details"""
        return self._window_funcs

    @window_funcs.setter
    def window_funcs(
        self,
        window_funcs: tuple[WindowFuncCallable | None, ...] | WindowFuncCallable | None,
    ):
        if window_funcs is None:
            self._window_funcs = None
            return

        if callable(window_funcs):
            window_funcs = (window_funcs,)

        # if all are None
        if all([f is None for f in window_funcs]):
            self._window_funcs = None
            return

        self._validate_window_func(window_funcs)

        self._window_funcs = tuple(window_funcs)
        self._recompute_histogram()

    def _validate_window_func(self, funcs):
        if isinstance(funcs, (tuple, list)):
            for f in funcs:
                if f is None:
                    pass
                elif callable(f):
                    sig = inspect.signature(f)

                    if "axis" not in sig.parameters or "keepdims" not in sig.parameters:
                        raise TypeError(
                            f"Each window function must take an `axis` and `keepdims` argument, "
                            f"you passed: {f} with the following function signature: {sig}"
                        )
                else:
                    raise TypeError(
                        f"`window_funcs` must be of type: tuple[Callable | None, ...], you have passed: {funcs}"
                    )

        if not (len(funcs) == self.n_slider_dims or self.n_slider_dims == 0):
            raise IndexError(
                f"number of `window_funcs` must be the same as the number of slider dims: {self.n_slider_dims}, "
                f"and you passed {len(funcs)} `window_funcs`: {funcs}"
            )

    @property
    def window_sizes(self) -> tuple[int | None, ...] | None:
        """get or set window sizes used for the corresponding window functions, see docstring for details"""
        return self._window_sizes

    @window_sizes.setter
    def window_sizes(self, window_sizes: tuple[int | None, ...] | int | None):
        if window_sizes is None:
            self._window_sizes = None
            return

        if isinstance(window_sizes, int):
            window_sizes = (window_sizes,)

        # if all are None
        if all([w is None for w in window_sizes]):
            self._window_sizes = None
            return

        if not all([isinstance(w, (int)) or w is None for w in window_sizes]):
            raise TypeError(
                f"`window_sizes` must be of type: tuple[int | None, ...] | int | None, you have passed: {window_sizes}"
            )

        # if not (len(window_sizes) == self.n_slider_dims or self.n_slider_dims == 0):
        #     raise IndexError(
        #         f"number of `window_sizes` must be the same as the number of slider dims, "
        #         f"i.e. `data.ndim` - n_display_dims, your data array has {self.ndim} dimensions "
        #         f"and you passed {len(window_sizes)} `window_sizes`: {window_sizes}"
        #     )

        # make all window sizes are valid numbers
        _window_sizes = list()
        for i, w in enumerate(window_sizes):
            if w is None:
                _window_sizes.append(None)
                continue

            if w < 0:
                raise ValueError(
                    f"negative window size passed, all `window_sizes` must be positive "
                    f"integers or `None`, you passed: {_window_sizes}"
                )

            if w == 0 or w == 1:
                # this is not a real window, set as None
                w = None

            elif w % 2 == 0:
                # odd window sizes makes most sense
                warn(
                    f"provided even window size: {w} in dim: {i}, adding `1` to make it odd"
                )
                w += 1

            _window_sizes.append(w)

        self._window_sizes = tuple(_window_sizes)

    @property
    def window_order(self) -> tuple[int, ...] | None:
        """get or set dimension order in which window functions are applied"""
        return self._window_order

    @window_order.setter
    def window_order(self, order: tuple[int] | None):
        if order is None:
            self._window_order = None
            return

        if order is not None:
            if not all([d <= self.n_slider_dims for d in order]):
                raise IndexError(
                    f"all `window_order` entries must be <= n_slider_dims\n"
                    f"`n_slider_dims` is: {self.n_slider_dims}, you have passed `window_order`: {order}"
                )

            if not all([d >= 0 for d in order]):
                raise IndexError(
                    f"all `window_order` entires must be >= 0, you have passed: {order}"
                )

        self._window_order = tuple(order)

    @property
    def spatial_func(self) -> Callable[[ArrayProtocol], ArrayProtocol] | None:
        pass

    # @property
    # def slider_dims(self) -> tuple[int, ...] | None:
    #     pass

    @property
    def slider_index_maps(self) -> tuple[Callable[[Any], int] | None, ...]:
        return self._slider_index_maps

    @slider_index_maps.setter
    def slider_index_maps(self, maps):
        self._maps = self._validate_slider_index_maps(maps)

    def _validate_slider_index_maps(self, maps):
        if maps is not None:
            if not all([callable(m) or m is None for m in maps]):
                raise TypeError

        return maps

    def __getitem__(self, item: tuple[Any, ...]) -> ArrayProtocol:
        pass
